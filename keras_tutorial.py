# -*- coding: utf-8 -*-
"""Keras-tutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u1SPccWz_Kze_u6MkuBogTUSk7zQnsFy
"""

from tensorflow import keras

import numpy as np
from random import randint
from sklearn.preprocessing import MinMaxScaler

from keras import backend as k
from keras.models import Sequential
from keras.layers import Activation
from keras.layers.core import Dense
from keras.optimizers import Adam
from keras.metrics import categorical_crossentropy

train_labels=[]
train_samples=[]

for i in range(50):
   random_younger=randint(13,64)
   train_samples.append(random_younger)
   train_labels.append(0)
  
   random_older=randint(65,100)
   train_samples.append(random_older)
   train_labels.append(1) 





for i in range(1000):
  random_younger=randint(13,64)
  train_samples.append(random_younger)
  train_labels.append(1)
  
  random_older=randint(65,100)
  train_samples.append(random_older)
  train_labels.append(0)

"""# Keras is expecting features and lables as numpy arrays"""

train_labels=np.array(train_labels)
train_samples=np.array(train_samples)

"""#Features Sacling for faster computation"""

#first you have to define the scaler range 

scaler=MinMaxScaler(feature_range=(0,1))

## Scaling all the data to the scaler , 

scaled_train_examples=scaler.fit_transform((train_samples).reshape(-1,1))

"""# Defining Layers for the Neural network Sequential(l1,l2,l3,....) We can also use
model.add(l5) #Or
model.append(l6)
"""

#if the activation function is not defined , Keras will define teh linear activation functon

model=Sequential([Dense(16, input_shape=(1,) ,activation='relu'),Dense(32,activation='relu'),Dense(2,activation='softmax')])

"""relu is nearlz the same as logisic regression. Softmax is to force the output to have probability distribution"""

model.summary()

"""# Train an artificial neural network

lr is the learning rate 
Loss is the choice of the cost function , it may be mean square error or mean absolute error
"""

model.compile(Adam(lr=0.0001), loss ='sparse_categorical_crossentropy', metrics=['accuracy'])

"""# we are fitting our data to the model
The training Examples , the labels and the batch 
the batch is how many of my training examples I want to process in a time
Example by Example or group by group
"""

model.fit(scaled_train_examples,train_labels,validation_split=0.1,batch_size=10,epochs=20,shuffle=True,verbose=2)

"""#Building a Validation Set Using Keras
The validation set will always be the last 10% of the data , there will be no shuffle in the data

# Predicting
"""

test_labels=[]
test_samples=[]

for i in range(10):
   random_younger=randint(13,64)
   test_samples.append(random_younger)
   test_labels.append(0)
  
   random_older=randint(65,100)
   test_samples.append(random_older)
   test_labels.append(1) 





for i in range(200):
  random_younger=randint(13,64)
  test_samples.append(random_younger)
  test_labels.append(1)
  
  random_older=randint(65,100)
  test_samples.append(random_older)
  test_labels.append(0)
  
  
test_labels=np.array(test_labels)
test_samples=np.array(test_samples)

  
#first you have to define the scaler range 

scaler=MinMaxScaler(feature_range=(0,1))

## Scaling all the data to the scaler , 

scaled_test_examples=scaler.fit_transform((test_samples).reshape(-1,1))

predictions=model.predict_classes(scaled_test_examples,batch_size=10,verbose=0)

for i in predictions:
  print (i)

predictions1=model.predict(scaled_test_examples,batch_size=10,verbose=0)

predictions1

"""## Confusion Matrix"""

# % matplotlib inline
import sklearn
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt


predictions_new=[]

for i in predictions:

   predictions_new.append(i)

cm=confusion_matrix(test_labels,predictions)

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()

cm_plot_labels=['no_side_effects','had_side_effects']
plot_confusion_matrix(cm,cm_plot_labels,title='confusion_Matrix')

model.save('medical_trial_model.h')

import pandas as pd
sf =pd.DataFrame ({'x':[1,2,3,4,5,6],
'y':['a','b','c','d','e','f']})

sf